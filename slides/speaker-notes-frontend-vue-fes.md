## オープニング

はい、ユウトです。今日は「JavaScriptのAPIはどこから来る？」という話をします。よろしくお願いします。

今日、このイベントに来られている方はおそらく皆さん、フロントエンド/バックエンド/モバイルで、JavaScript/TypeScriptを使って開発をしている方々かなと思っています。

なので今回は、「フレームワークを使った」みたいな話ではなく、皆さんが当たり前のように使っているAPIたちがどのように生み出されているのかを、自分の趣味のOSS活動を軸に話をしていきたいと思っています。

## 問題提起

なんで話すのかって感じかもですが、フロントエンドの移り変わりが早すぎて疲れませんか？新しいフレームワークが月1で出る現状で、「フロントエンドの移り変わりが早い」みたいな現象はより加速していくと思っています。

でもよく考えてみてください。どんなフレームワークを使っても、結局は`Array.map()`や`fetch()`を使っていますよね？

僕はもうそういうの追うの疲れたのと、一番根っこの部分の知識があればあるほど、追従も楽に容易になる。あと自分で作って選択肢も生まれる。と思っているので、最近は仕様をできる限り追うようにしています。

根本を知れば「また新しいの？」→「ああ、これはあれのラッパーね」に変わります。

今日は皆が使うAPIがどこから来るのかを知って、技術選定の軸を作りましょう。

## APIの分類

例えばですが、以下のAPIはJSの中でもよく使われているものかなと思っています。

- Array.prototype.map
- console.log
- fetch

そしてこれらのAPIには、以下のような違いがあります。

- Array.prototype.map: JavaScript Engine（ECMA-262）
- console.log: Runtime（WHATWG/WinterTC）
- fetch: Runtime（WHATWG/WinterTC）

これらのAPIをベースにして話をしていこうかなと思っています。

## Engine系APIの実装現場

では早速Array.prototype.mapの話です。

これはJavaScript Engineが持っているAPIです。仕様書も、TC39の、ECMA-262という仕様書に記載があります。

有名なJavaScript Engineでいうと、GoogleのV8、AppleのJSC、MozillaのSpiderMonkeyとかがあります。そして僕はNovaというJavaScript Engineにコントリビュートしています。

先に言っておきますが、「なんで作るのか」という問いには「作りたいから」という回答です。作りたいものに理由はいるのかと。もちろん厳密に作る理由はありますが、僕がそれを詳しく説明できるほどコンパイラへの知識がないだけでもあります。

で、ECMA-262の仕様書通りにAPIがつくられているかをチェックするために、Test262というものがあります。Novaは現状75%です。

主要なJavaScript EngineのTest262通過率は90%超えているので、あと少しといったところです。

最近ついにRegExpに取り組み始めているので、来月くらいに80%は行くんじゃないかなと思っています。

## Runtime系APIの実装現場

ただ、皆さんは普段どのランタイムがどのEngineを使っているかなんて意識しないですよね。ましてやEngineをcloneして手元でAPIを実行するみたいなこともしないですよね。

おそらく9割くらいの人は、EngineのAPIをRuntimeを介して実行していると思います。

というわけで、ここからはconsole.logやfetchの話をしていきます。

JavaScript Runtimeといえば、皆さん何を思い浮かべますか？

世界で最も人気なランタイムは、多分Chromeです。ただSafariも同じくらいかもしれないです。RuntimeはJavaScriptの実行環境なので、ブラウザもJavaScript Runtimeに分類されます。

サーバーサイドでいうと、Nodeが一番ユーザー数が多いと思います。ただ最近だとDenoやBunもありますよね。

そして、consoleやfetchは、これらのRuntimeが作っています。

ChromeはV8、SafariはJSC、NodeはV8、DenoもV8、だけどDenoはRustでV8はC++なので、rust_v8というRustとのバインディングをする工夫もしている。BunもJSCを使っているがZigとC++なので、同じようにバインディングしている。

そして僕も、Andromedaというイカした名前のJavaScript Runtimeを作っています。もともとNovaにコントリビュートしていた人に誘ってもらって、作り始めました。こっちはメンバーです。あとWinterTCというサーバーサイドランタイムの標準化を行うテクニカルコミッティーのInvited Expertもしています。今のところほぼ何もできてないですが。

AndromedaはNovaを使ったJavaScript Runtimeです。いわゆるサーバーサイドランタイムであります。

僕のメンバーとしての目標は、minimal common APIを実装することです。直近だと、fetchを作っています。

fetchの仕様って膨大で、自分が思っていた以上に大きいものになっています。Request/Response/Headerクラスとかもfetchの範囲になってくるし、さらにfetch methodからfetching/main fetch/schema fetch/http fetch/http network fetchみたいに分類されていたりします。仕様書1000ページ超えです。

もしこういう標準APIにコントリビュートしたい、読んでみたいと思うのであれば、サーバーサイドランタイムがおすすめかなと思ってます。

Engineの実装はいかんせん複雑で、前提知識も結構必要です。

Runtime、特にNodeは仕様書に書いてある通りに実装してくれている部分が多いので、それなりに開発経験があれば読んでいけると思います。fetchは意外とTODOも残っていたりするので、そのTODOを解消するために仕様書と実装を照らし合わせながら読み進めていくと、良いのではないでしょうか。

## エコシステム戦略

ここまでの話をまとめます。

先ほどの三つのAPIたちは、JavaScript Engine/Runtimeによってつくられている。Engine側の仕様はECMA-262、Runtimeの仕様はWHATWG/WinterTCになる。

さて、ここからはより作っているEngine/Runtimeが現場で使われるようになるためにはどうすればいいのかも少し考えてみましょう。

ある特定の課題を解決するライブラリなどであれば、必然的にユーザーは増えるでしょう。

しかしRuntimeは少し特殊です。Bunのようにクッソ早い。みたいなことでもない限り、難しいです。

Andromedaは理論上早いけど、本当に早いかどうかは検証する段階ではなく、作っていく過程です。

僕が考えるに、既存のエコシステムに乗っかることが、一番早いと思っています。

さて、今日本で最もホットなJSソフトウェアってなんですか？

マルチランタイムサポートが可能なHonoのAdaptorとして提供することが、自分が作り始めてからの密かな目標です。だってランタイムですから。

サーバーサイドでは使うランタイムを使い人が切り替え可能なのが良さであると思うので、個人開発とかで面白そうだし使ってみようかな。みたいなくらいになればいいかなと思ってます。

## クロージング

もし興味を持ったのであれば、engineでもruntimeでもいいので、コードと仕様書を見比べてみましょう。おすすめはコードを少しいじって、テスト走らせてみていくと実際に今日のチェックもできるので理解が進むと思います。

EngineとRuntimeの挙動を知ると自分たちが知らないJavaScriptの挙動を知れるので、めっちゃ楽しいと思います！ぜひ皆さんも興味があれば触ってみてください！